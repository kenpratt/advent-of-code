use std::{
    env,
    fs::{self, File},
    io::Write,
    path::PathBuf,
    time::Instant,
};

use regex::Regex;

fn main() {
    let timer = Instant::now();
    let start = timer.elapsed();

    let modules = explore();

    for (year, _days) in &modules {
        println!("cargo:rerun-if-changed=src/{}", year.name);
    }

    write_days_file(&modules);

    for (year, days) in &modules {
        write_year_mod_file(year, days);
    }

    let duration = timer.elapsed() - start;
    println!(
        "cargo:warning={}",
        format!("build.rs took {}ms", duration.as_millis())
    );
}

struct Module {
    path: PathBuf,
    name: String,
    number: usize,
}

fn explore() -> Vec<(Module, Vec<Module>)> {
    find_year_modules()
        .into_iter()
        .map(|year| {
            let days = find_day_modules(&year);
            (year, days)
        })
        .collect()
}

fn find_year_modules() -> Vec<Module> {
    let path = src_path();
    let year_re = Regex::new(r"\Ay(\d{4})\z").unwrap();
    find_modules(&path, &year_re)
}

fn find_day_modules(year: &Module) -> Vec<Module> {
    let day_re = Regex::new(r"\Aday_(\d{2})_").unwrap();
    find_modules(&year.path, &day_re)
}

fn find_modules(dir: &PathBuf, re: &Regex) -> Vec<Module> {
    let entries = fs::read_dir(dir).unwrap();
    let mut modules: Vec<Module> = entries
        .into_iter()
        .map(|entry| entry.unwrap().path())
        .filter(|path| path.is_dir())
        .filter_map(|path| {
            let name = path.file_name().unwrap().to_str().unwrap().to_string();
            match re.captures(&name) {
                Some(caps) => {
                    let number = caps.get(1).unwrap().as_str().parse::<usize>().unwrap();
                    Some(Module { path, name, number })
                }
                None => None,
            }
        })
        .collect();
    modules.sort_by(|a, b| a.name.cmp(&b.name));
    modules
}

fn src_path() -> PathBuf {
    let current_dir = env::current_dir().unwrap();
    let mut path = current_dir.clone();
    path.push("src");
    path
}

fn write_year_mod_file(year: &Module, days: &[Module]) {
    let mut output_path = year.path.clone();
    output_path.push("mod.rs");

    let mut file = File::create(output_path).unwrap();
    write!(file, "// generated by build.rs\n").unwrap();

    for day in days {
        write!(file, "pub mod {};\n", &day.name).unwrap();
    }
}

fn write_days_file(years: &[(Module, Vec<Module>)]) {
    let mut output_path = src_path();
    output_path.push("days.rs");

    let mut file = File::create(output_path).unwrap();
    write!(
        file,
        "// generated by build.rs
use crate::interface::*;
use crate::template;\n"
    )
    .unwrap();

    for (year, _days) in years {
        write!(file, "use crate::{};\n", &year.name).unwrap();
    }

    write!(file, "\npub const YEARS: [usize; {}] = [\n", years.len()).unwrap();

    for (year, _days) in years {
        write!(file, "    {},\n", &year.number).unwrap();
    }

    for (year, days) in years {
        write!(
            file,
            "];\n\npub const DAYS_{}: [usize; {}] = [\n",
            year.number,
            days.len()
        )
        .unwrap();

        for day in days {
            write!(file, "    {},\n", day.number).unwrap();
        }
    }

    file.write_all(
        "];

pub fn days_for_year(year: usize) -> &'static [usize] {
    match year {
"
        .as_bytes(),
    )
    .unwrap();

    for (year, _days) in years {
        write!(
            file,
            "        {} => &DAYS_{},\n",
            &year.number, &year.number
        )
        .unwrap();
    }

    file.write_all(
        "        _ => panic!(\"Unknown year: {}\", year),
    }
}

pub fn run_fn(year: usize, day: usize) -> Option<fn(bool)> {
    match (year, day) {
        (_, 0) => Some(template::Day::run),
"
        .as_bytes(),
    )
    .unwrap();

    for (year, days) in years {
        for day in days {
            write!(
                file,
                "        ({}, {}) => Some({}::{}::Day::run),\n",
                &year.number, &day.number, &year.name, &day.name
            )
            .unwrap();
        }
    }

    file.write_all(
        "        _ => return None,
    }
}
"
        .as_bytes(),
    )
    .unwrap();
}
